# 多进程 VS 多线程 VS 线程池 VS EventLoop

在现在的编程过程中，经常听到多进程，多线程，线程池，EventLoop 的概念，选择一个正确的驱动模型，有助于提升代码的性能。

**注：本文仅仅讨论并发的情况。**

## 进程和线程

* 进程：操作系统中**资源管理对象**，管理虚拟内存，文件句柄，线程等资源，但是**进程不是执行单元**。

* 线程：**具体的执行单元**。CPU是实际的物理执行单元，通过**寄存器**可以控制CPU执行的代码以及状态。而线程就是包含了一个任务的CPU上下文（寄存器），任务状态（就绪|阻塞|运行），所属用户等信息的对象。操作系统接收到时间中断（INT）后，**通过轮转线程中的CPU上下文（寄存器）信息，实现了多任务的轮转**。

## 多进程

多进程：针对并发请求，一个请求开启一个进程进行处理。早起CGI就是这么干的。

代表：早期PHP，CGI类

优点：

* 一个业务进程奔溃不影响另外一个业务进程，从操作系统层面上隔离业务执行
* 如果进程采用Socket之类的RPC调用，那么非常容易部署到网络环境上

缺点：

* RPC调用比较难以编写
* 频繁的开启和关闭进程，性能比较差
* 不允许内存共享（排除内核支持情况）

## 多线程

多线程：针对不同的业务逻辑，并发的开启多个线程进行执行。

代表：早期 Tomcat Bio模型

优点：

* 内存是共享的
* 编写并发模型比较方便
* 有效的利用多核CPU

缺点：

* 并发量过大的时候，开启了太多线程（有些阻塞在IO），导致CPU上下文切换太过频繁
* 过多的线程，会占用许多内存（2MB/Thread），造成服务器奔溃
* 需要做并发控制

## 线程池

线程池：开启固定的线程，当有请求过来的时候，查询是否存在空闲线程，如果存在，则使用空闲线程执行任务，否则加入等待执行队列

代表：Netty，Jetty

优点：

* 有效的利用多核CPU
* 内存共享
* 减少了CPU上下文切换消耗

缺点：

* 还是存在一部分IO等待，导致CPU无法有效的利用
* 需要做并发控制

## EventLoop

EventLoop：仅仅开启一条main线程执行任务，其他所有的IO操作等，都放在后台线程中执行，对于新的请求，都加入到queue中，等待main线程调度。

代表：Node.js

优点：

* 大部分情况下，不需要做并发控制
* 减少了CPU上下文切换消耗

缺点：

* 无法有效利用多核CPU（当然可以多开EventLoop）
* 回调陷进，调试比较困难

## 总结

上述的各种编程模型，都出现在我们的实际的开发过程中，其核心思想为：**有效的利用CPU，减少阻塞等待和非业务代码（如上下文切换）的运行时间占用。**

## 参考

* [linux 惊群问题](http://blog.csdn.net/liujiyong7/article/details/43346829)
* [什么是 Event Loop](http://www.ruanyifeng.com/blog/2013/10/event_loop.html)
* [Java并发编程：线程池的使用](http://www.cnblogs.com/dolphin0520/p/3932921.html)